

http://doc.perl6.org/language/functions

There's also a lot of info on the syntax of declaring functions in 
../syntax/README.


Verbiage {#{{{
    Code Objects
        This term covers methods, subroutines, multi-dispatch routines, blocks 
        with code.

    Routines
        sub, method, regex, submethod.  Basically, code objects except for 
        blocks.

    arity
        The minimum number of positional arguments that must be passed to a 
        routine.
    
}#}}}

Scoping {#{{{

    Subs are lexically scoped.  This behaves as you'd expect:
        sub foo { say "outer"; }
        foo();
        {
            sub foo { say "inner"; }
            foo();
        }
        foo();

}#}}}
Blocks {#{{{
    Blocks are a class in p6.
        http://doc.perl6.org/type/Block

    Regular block:
        for 1..4 -> $a {
            say $a;
        }

    Remember that you can do this:
        for 1..4 -> $a, $b {
            say $a ~ $b;
        }
    Output:
        12
        34
    If you changed the range there to 1..5, your block would throw an 
    exception, as the third time through, $b would be undefined.


    The "thingy" on the right of the -> in the blocks above isn't just a loop 
    variable.  It's a signature.
            my @nums = <1 2 3 4 5>;
            for @nums -> Int $n {
                say $n;                     # fine.
            }


            my @stuff = <1 2 3 'blargle' 4 5>;
            for @stuff -> Int $n {
                say $n;                     # Prints out 1, 2, and 3, but then
                                            # explodes when it gets to 
                                            # 'blargle'.
            }

}#}}}
Signatures {#{{{
    A sub signature is also its own class:
        http://doc.perl6.org/type/Signature

            sub greet($name)        { ... }
            sub greet(Str $name)    { ... }
            sub say_age(Str $name, Int $age where $age > 0 and $age < 120 ) { ... }

    See also the note about signature literals in the literals section of 
    ../syntax/README

}#}}}
Methods {#{{{
    The first parameter in a method declaration can be the invocant, in which 
    case it gets followed by a colon.  Otherwise, parameters are separated by 
    commas.  Basically, that first parameter is $self.

    class Person {
        method whatami( $me: ) {
            say "I'm a member of $me.^name()"
        }
    }

}#}}}

General parameter info {#{{{
    
    Parameters in p6 are read-only by default.

            sub add (Int $num) {
                $num += 1;              # GONNNNG!
            }


    Sometimes you do want your argument to be fully modifiable:
            sub inc_by_two (Int $num is rw) {
                $num += 2;
            }
            my $var = 3;
            inc_by_two($var);
            say $var;               # 5


    Sometimes you want to modify it inside the routine but not affect the 
    outside world:
            sub add_two (Int $num is copy) {
                $num += 2;
                say "I now have -$num-";
            }

            my $var = 3;
            add_two($var);      # I now have -5-
            say $var;           # 3


}#}}}

Type Constraints, defined {#{{{
    
    So this makes perfect sense:
            sub sayit (Str $foo) {
                say "--$foo--";
            }

            sayit('blarg');         # fine
            sayit('1');             # fine

        But:
            sayit(1)                # GONNNG!

        "Calling sayit(Int) will never work with declared signature (Str $foo)"


    But along with using the builtin types like Str and Int, you can also use 
    your own types.
            class Jontest { has $.foo = 'bar'; }

            sub sayit (Jontest $jon) {
                say "--{$jon.foo}--";
            }

            my $j = Jontest.new();
            sayit($j);                      # fine
            sayit("blarg");                 # GONNNG, obviously.



    This sub appears to be perfectly cromulent:
            sub greet (Str $name) {
                say "Hello, $name!";
            }

    But what happens when we do this:
            my Str $name;
            greet($name);
            say "Still here!"

    Whoopsie.  We declared $name as a string but didn't define it.  greet() 
    can't complain about the type, since we _are_ passing in a Str type as 
    required.

    But then greet() tries to 'say' that Str $name.  Since it's undefined, we 
    end up with a warning.  Our program runs to the end, but the output is 
    ugly:
            Use of uninitialized value of type Str in string context
            Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in sub greet at ./test.p6 line 4
            Hello, !
            Still here!


    So the fix here is to declare the parameter as "must be defined":
            sub greet (Str:D $name) {
                say "Hello, $name!";
            }
            my Str $name;
            greet($name);
            say "Still here!"

        So now, instead of a warning, we get a fatal:
                Parameter '$name' requires an instance of type Str, but a type 
                object was passed.  Did you forget a .new?
            Not the most clearly-worded error perhaps, but it'll do.


        You can defined-constrain a variable in these ways:
            - :D    variable must be defined (as above)
            - :U    variable must be undefined
            - :_    variable is explicitly allowed to be either defined or
                    undefined

}#}}}
Where block, subsets {#{{{
    
    Along with being able to constrain the variable type (Int, Str, etc), you 
    can also add more specific constraints:
            
            sub num_fingers (Int $num where {$num > 0} ) {
                say "After the accident, you have $num fingers.";

                if $num == 10   { say "Congratulations!"; }
                else            { say "Sorry to hear about that."; }
            }

            num_fingers(10);        # fine
            num_fingers(8);         # fine
            num_fingers(-8);        # GONNNG!  Runtime error.


    Got coords?
            sub lower-right (Int $x where {$x > 0}, Int $y where {$y < 0} ) {
                say "Your point is located at ($x, $y).";
            }

    That's getting a bit noisy, and we've only got two params.  Let's break it 
    up a bit:
            sub lower-right (
                Int $x where {$x > 0}, 
                Int $y where {$y < 0}
            ) {
                say "Your point is located at ($x, $y).";
            }

        That's fine.


    Hell, if your where clause is unwieldy, and especially if you're using the 
    same where clause more than once:
            sub gt_zero (Int $a where {$a > 0}) { True }
            sub lt_zero (Int $a where {$a < 0}) { True }

            sub lower-right (
                Int $x where gt_zero($x),
                Int $y where lt_zero($y)
            ) {
                say "Your point is located at ($x, $y).";
            }


    While that works, p6 gives us subsets for doing exactly that.
            subset gt_zero of Int where * > 0;
            subset lt_zero of Int where * < 0;

            sub lower-right ( gt_zero $x, lt_zero $y ) {
                say "Your point is located at ($x, $y).";
            }


    See "More on subsets" below for some other examples I pulled from a 
    youtube video.

}#}}}
Positional Parameters {#{{{

    Without any other mucking about, parameters are positional.
            sub greet ($greeting, $name) {
                say "$greeting, $name!"
            }
            greet( "Howdy", "Jon" );


    Positional parameters are required by default.  We can make them optional 
    in two ways. 

    First, we can provide a default value:
            sub the_answer( Int $ans = 42 ) {
                say "The answer is $ans.";
            }
            the_answer(11);     # The answer is 11.
            the_answer();       # The answer is 42.

    Second, we can make the parameter optional with no default by appending a 
    question mark:
            sub the_answer( Int $ans? ) {
                if $ans {
                    say "The answer is $ans.";
                }
                else {
                    say "I dunno the answer.";
                }
            }
            the_answer(11);     # The answer is 11.
            the_answer();       # I dunno the answer.



    But, if you make a parameter optional, you're going to have to check if it 
    was passed in or not, which is going to result in the very p5-y looking 
    code you see above.

    Instead of messing with optional parameters, use multi routines instead:
            sub the_answer()         { say "I dunno the answer." }
            sub the_answer(Int $ans) { say "The answer is $ans." }




}#}}}
Named Parameters {#{{{

    We get named parameters by preceding them with a colon in the signature:

            sub greet( :$greeting, :$name ) {
                say "$greeting, $name!"
            }

        To give our named params default values:
            sub greet( :$greeting = 'Hello', :$name = 'Joe' ) {
                say "$greeting, $name!"
            }



    *********************************************

                        Named parameters are optional by default!

    
            sub greet( :$greeting, :$name ) {
                say "This is the greeting routine.";
                say "$greeting, $name!" if $greeting and $name;
            }
            greet();        # This is the greeting routine


    So these two signatures are identical:
            sub greet( :$greeting, :$name ) { }
            sub greet( :$greeting?, :$name? ) { }

    If you want to make your named parameters required, add bangs:
            sub greet( :$greeting!, :$name! ) { }

    Or, remember to add default values:
            sub greet( :$greeting = 'Hello', :$name = 'Joe' ) { }


    THAT'S IMPORTANT READ IT AGAIN!
        It's going to be really nice in p6 to not have to constantly check if 
        a passed variable is set or not anymore, since our signatures have 
        already done that for us.  We won't be doing a lot of this anymore:

            if( $arg1 and $arg1 + 0 == $arg1 ) {
                if( $arg2 and $arg2 + 0 == $arg2 ) {
                    $rslt = $arg1 + $arg2;
                    return $rslt;
                }
                else { die $arg2 was not passed or is not a number }
            }
            else { die $arg1 was not passed or is not a number }

        Because our signature already ensured that $arg1 and $arg2 already 
        exist, and are Ints, and whatever else we need.

        But with default named parameters, those args may not be set!


    If your routine is expecting your named params to always be set, always 
    include those bangs, or (even better) provide defaults of your own!

    *********************************************


    Calling a function that has named parameters
        There are a bunch of different ways to do this. 

        Passing in strings:
            greet( name => 'Steve', greeting => 'Hola' );
            greet( :name<Jon>, :greeting<Blarg> );
            greet( :name('Jon'), :greeting('Blarg') );

        Passing in variables instead of strings:
            my $name     = 'Fred';
            my $greeting = 'Hello';
            greet( name => $name, greeting => $greeting );
            greet( :name($name), :greeting($greeting) );
            greet( :name<<$name>>, :greeting<<$greeting>> );

        Remember that <> is a non-interpolating quote construct, and <<>> is 
        the same except it does interpolate.

        


    If the name of the variable you're passing in is the same name as the 
    variable specified in the signature, you can just prefix your variable 
    with a colon.
            my $name     = 'Fred';          # same as in the signature
            my $greeting = 'Hello';`        # same as in the signature
            greet( :$greeting, :$name );

    Because of this, you should use names in your signature that really make 
    sense.  However, you still might want to use short variable names in the 
    routine's code because Laziness.

    So in our signature, we can specify a meaningful incoming name along with 
    a conveniently short variable:
        sub greet( :greeting($g), :name($n) ) {
            say "$g, $n!"
        }

        greet( :greeting('Hi'), :name('Jon') );
            
}#}}}
Slurpy (Variadic) Parameters {#{{{

    This allows your parameter list (or even just part of it) to behave more 
    like p5's @_.


    A list (array or hash) parameter can be made slurpy by appending a splat.  
    This obviously has to be the final parameter.
            sub greet ($greeting, *@names) {
                for @names -> $a {
                    say "$greeting, $a!";
                }
            }
            greet('Hi', 'Jon', 'Kermit');



    If we're passing an array of names, then jamming another scalar on at the 
    end.  That extra scalar gets slurped up:
            my @arr = <jon john kermit>;
            greet("Hello", @arr, "Alison");



    But these slurpy parameters aren't totall like p5's.  You can have both 
    Listlike and Associative slurpys:
            sub foo( $one, *@arr, *%hash ) {
                say $one;
                say @arr;
                say %hash;
            }

}#}}}
Combining named and positional parameters {#{{{
    
    Here, we're using the named parameters :$greeting and :$name as before, 
    but we're also adding $age as a positional parameter.

    Positional parameters must come before named parameters in the signature:
        sub greet_combo( $age, :$greeting, :$name ) {
            say "$greeting, $name!  You are $age years old."
        }

    But when we call the sub, we can put the positional parameter anywhere.  
    All of these do the same thing:
        greet( name => 'Steve', greeting => 'Hola', 21 );
        greet( name => 'Steve', 21, greeting => 'Hola' );
        greet( 21, name => 'Steve', greeting => 'Hola' );
    
}#}}}
Capture parameters {#{{{
    You can prefix a parameter with a vertical bar (pipe) to make it a 
    Capture, which uses up all remaining positional and named arguments.

    CHECK
    This seems to be like a slurp.  In fact, I'm unclear how this is different 
    from a slurp.  Perhaps the slurp doesn't use up all named args or some 
    such.

    See the MyKid and MyParent classes in ./subs.p6 for an example of this 
    capture being used.
}#}}}
Parameter traits and modifiers {#{{{
    
    Parameters are RO by default, and bound to their argument.  If you try to 
    modify such a variable inside a routine, you get:
        Cannot assign to a readonly variable or a value


    This allows the parameter to be written to, but doesn't clobber the 
    original:
        sub hello ($name is copy) {
            $name = $name.uc;
            say $name;
        }
        my $name = 'jon';
        hello($name);       # JON
        say $name;          # jon


    This allows the parameter to be written to, and DOES clobber the original:
        sub hello ($name is rw) {
            $name = $name.uc;
            say $name;
        }
        my $name = 'jon';
        hello($name);       # JON
        say $name;          # JON


    With slurpy parameters, "is rw" is listed as being "reserved for future 
    use by language designers".  Which translates roughly to "don't do dat".


    There's also a "raw" trait that gets applied to parameters whose names are 
    preceded by a backslash.  These params do not get any other sigil.
        sub set_var(\variable) {
            variable = "foobar";
        }
        set_var( my $foo );     # this works.
        say $foo;

        set_var( 'blargle' );   # this does not.

}#}}}
Interspersing Arguments {#{{{

    This can all get a little confusing:

            sub mysub( $one, *@arr, :$foo, *%hash ) {
                say $one;
                say $foo;
                say @arr;
                say %hash;
            }

            mysub('one', 'two', :foo('FOO'), 'three', 'four', jon => 'barton', kermit => 'jackson', 'five');


    When eyeballing through code like that, remember that named parameters can 
    be passed in any order.  The signature is specifically looking for 'foo' 
    as a named parameter, so accept that's been satisfied and remove it from 
    the list:
            sub mysub( $one, *@arr, *%hash ) { }
            mysub('one', 'two', 'three', 'four', jon => 'barton', kermit => 'jackson', 'five');


        Next, the sub is specifically looking for a single positional 
        parameter to go into $one.  It's been satisfied, take it out:
            sub mysub( *@arr, *%hash ) { }
            mysub('two', 'three', 'four', jon => 'barton', kermit => 'jackson', 'five');


        We're down to just our slurpy params.  Again, named params, even 
        slurpy ones, can go in any order.  They've been satisfied, so take 
        them out:
            sub mysub( *@arr ) { }
            mysub('two', 'three', 'four', 'five');


        ...and what's left goes into @arr.




}#}}}
Methods called on parameters {#{{{
    Inside a sub, you can call various methods on the parameters to inspect 
    them.

    NYI

    I'm unclear if this is a case of nyi or if I'm just not getting it.

    The docs tell me there are a bunch of these ("method rw", "method copy", 
    etc), and that these "Return True for 'is rw' parameters" (or is copy or 
    what have you).

    However, when I add code like this to any of the subs:
            sub foo(Str $foo is rw) {
                say $foo;
                say $foo.rw;
            }
            my $var = 'blarg';
            foo( $var );

        I'm being told that "the method 'rw' not found".  If you comment out 
        the call to .rw, the rest of the code works.

}#}}}
Type Coercisons {#{{{

    This isn't specifically covered in the tut, but it's used in another 
    context, so it should be mentioned.

    Start with this example:
        sub say_string(Str $string) {
            say "--$string--";
        }
        say_string( 'hello' );

    Fantastic.  It's pretty clear that this will blow up:
        say_string( 1 );

    Since 1 is an Int and not a string.  We'd need to pass the string version 
    for this to work:
        say_string( "1" );




    But really, what if we wanted to say "fuck it" and let them send an int.  
    We'll just convert it and print it, since that's surely what the user 
    wants here.  

    We can do that just by changing the signature:
        sub say_string_better(Str() $string) {
            say "--$string--";
        }

    Note the use of "Str()" -  the parens mean we're casting the value in 
    $string into a Str type.  Since we're doing that, we can now do this just 
    fine:
        say_string_better( 1 );
    
}#}}}
Return types {#{{{

    Specify the return type:
            sub lower-right ( gt_zero $x, lt_zero $y ) returns Str {
                "Your point is located at ($x, $y).";
            }
            say lower-right(3, -9);

    If we'd written that this way:
            sub lower-right ( gt_zero $x, lt_zero $y ) returns Str {
                1;
            }
            say lower-right(3, -9);

        The call would result in this runtime error:
            "Type check failed for return value; expected Str but got Int"



    Shortcut
            sub lower-right ( gt_zero $x, lt_zero $y --> Str ) {
                "Your point is located at ($x, $y).";
            }
            say lower-right(3, -9);

        CAREFUL WITH THAT!  We're not just replacing the word "returns" with 
        that long arrow.  Note that the long arrow and the return type it's 
        pointing to are both now INSIDE the signature.

        "returns $type" appears OUTSIDE the signature.

        Location aside, there's no practical difference between a sub declared 
        with "returns" and one declared with "-->".  Use what you prefer.


    "It's been at least two tutorial pages since we've needlessly tripped 
    somebody up.  Let's fuck with them with the 'returns' shortcut."

}#}}}
Multi-Dispatch (overloading) {#{{{
    Yay this now exists in p6.  Just declare a routine with the keyword 
    "multi" instead of "sub".

    This means you can freely start all your subs declared as just "sub", and 
    then cw it to "multi" if you realize you need to overload it.  Easy peasy.

    You can distinguish between multi routines by either the arity (the number 
    of arguments passed) or by the types of arguments.

        multi hello() {
            say "Why hello there.";
        }
        multi hello(Str $name) {
            say "Hello, $name, nice to meet you.";
        }
        multi hello(Int $num) {
            say "y helo thar" x $num;
        }


    When declaring a multi routine, it defaults to being a multi sub.  So the 
    word "sub" does not appear in the declarations above.  A more explicit 
    declaration would be:
        multi sub hello() {
          ### ^^^
            say "Why hello there.";
        }

    That's important, because if you want to overload a method in a class, you 
    do need to specify the word "method":
        Class Person {
            multi method hello() { say "hi" }
            multi method hello(Str $name) { say "hi, $name" }
        }


    Remember that "Any" is a valid type, so something like this is reasonable:
            multi method hello(Any $foo) { say "I got" ~ $foo.perl }
            multi method hello(Str $foo) { say "I got '$foo'." }

        ...so any non-string argument gets passed to the first hello(), and 
        that arg gets dumped out so you can see what you're dealing with.

    
    See the next section, Proto.

}#}}}
Proto {#{{{
    
    When using multi dispatch routines, you can first formally declare a 
    prototype of common arguments.

    This gets slightly hairy.  It can seem somewhat similar to Python's 
    decorators.


    Before getting hairy, the first example given is pretty basic:
        proto congratulate(Str $reason, Str $name, |) {*}

        multi congratulate($reason, $name) {
            say "Hooray for your $reason, $name";
        }

        multi congratulate($reason, $name, Int $rank) {
            say "Hooray for your $reason, $name -- you got rank $rank!";
        }

    The pipe in the proto declaration is an un-named Capture parameter.  This 
    means that we can now declare multi routines of this name ('congratulate') 
    that have zero or more additional args (past the forced $reason and 
    $name).

    The {*} in the proto declaration dispatches to the multi candidates.  More 
    on this when we start getting hairy.


    Great.  What's that get us?  So far, not a ton.  We still have to declare 
    $reason and $name in the signatures of the two subsequent multi routines.

    One benefit is that the .signature method now gives us more interesting 
    information.

        If we were to comment out the proto declaration, and then display the 
        signature, we'd get:
            say &congratulate.signature;    # (;; Mu | is raw)

        But when we put the proto declaration back again, and do the same 
        thing:
            say &congratulate.signature;    # (Str $reason, Str $name, | is raw)

        So that's more informative.



    Hairy time.  The proto can actually contain some verification code before 
    dispatching out to the candidates..
    
    Let's say we want to alert an admin under certain conditions.  We want to 
    be able to alert with either an error message or an error code (Int).  

    But we don't want to alert him outside of working hours, because we live 
    in magical rainbow land where employees don't get bothered when they're 
    not at work.

    proto notify(Str $user, Str $msg) {
        my \hour = DateTime.now.hour;
        if hour > 8 and hour < 22 {
            return {*};
        } else {
            # we can't notify someone when they might be sleeping
            return False;
        }
    }

        The conditional from the tut is broken; it used 'or' instead of 'and'.  
        Every hour is greater than 8 or less than 22.



    Note that {*} causes the multi candidates to be called with the args that 
    the proto was originally called with.  Parameter defaults and type 
    coercions from the proto do not apply to the candidates.

        The Str() coercion from the proto does not get passed along to the 
        multi routine:
            proto bad_coerce( Str() $string ) {*}
            multi bad_coerce( Str $string ) { $string.say; }
            bad_coerce( 1 );    # GONNNNG

        Same deal - the default value value of 'foobar' does not get passed 
        from the prototype to the multi routine:
            proto bad_default( $string = "foobar" ) {*}
            multi bad_default( $string ) { $string.say; }
            bad_default();

        This does not blow up.  The proto is trying to change the string's 
        value to "blargle", and that works too, but only in the proto.  When 
        we dispatch to the multi method, the original arg value, "foobar", is 
        what gets passed along, and ultimately printed out.
            proto bad_change( Str $string is copy ) { $string = "blargle"; return {*} }
            multi bad_change( $string ) { $string.say; }
            bad_change( "foobar" );

}#}}}
First-Class Functions {#{{{
    Functions are first-class objects in p6.

    Here's a basic sub declaration:
        sub square (Numeric $x) { $x * $x }

    We can assign this sub directly to a variable instead of to the symbol 
    table by not naming it:
        my $square_func = sub (Numeric $x) { $x * $x }

    If we go back to assuming it'd been declared normally, we can then access 
    it via the & sigil:
        sub square (Numeric $x) { $x * $x }
        ...
        my $square_func = &square;

    Either way we get the code into a scalar, we can then call it as:
        say $square_func(4);    # 16
}#}}}
Defining/Overloading Operators {#{{{
    http://doc.perl6.org/language/functions#Defining_Operators

    You can now define your own operators, or (perhaps more usefully) overload 
    existing operators.

    Operators are just oddly-named subroutines.  You have to define what 
    category your operator is, from the list:
        CATEGORY        EXAMPLE
        infix           *   4 * 3
        prefix          ++  ++$num
        postfix         ++  $num++
        circumfix       <>  <a b c>
        postcircumfix   []  @array[]

    Most of the time you're probably going to be overloading existing 
    operators, so you'll use the "multi" declarator.  You _can_ use "sub" if 
    you're inventing some new operator, I just don't see that happening all 
    that often.

    Anyway, the syntax for defining your own operator is:
        multi CAT:<OP> (SIGNATURE) { CODE }


    All of which is easier to understand in an example.


    Create a simple Person class and a couple objects with different ages:
        class Person {
            has Int $.age;
        }
        my $p1 = Person.new( age => 10 );
        my $p2 = Person.new( age => 20 );

    Now overload the addition operator to know how to deal with adding 
    Persons:
        multi infix:<+>(Person $a, Person $b) { $a.age + $b.age }

    Now we can add those two persons:
        say $p1 + $p2;      # 30 - yay!


    See the link up top of this section for more details on dealing with 
    categories other than the 'infix' category from this example.



    If you are defining a brand-new operator, you can set its precedence when 
    you declare it.  So if we're defining a new !! operator to do $stuff:
        multi infix:<!!>($a, $b) is tighter(&infix:<+>) { ...code.. }

    So now, our new !! operator will appear on the precedence table just 
    before the already-existing + operator.
        So, looking at the precedence table
            http://doc.perl6.org/language/operators#Operator_Precedence
        our new !! would create a new row, between "Multiplicative" and 
        "Additive", since !! "is tighter" than +, which is Additive.


    Along with setting precedence, you can also set your operator's 
    associativity.  See the URL top this section for details if needed.

}#}}}
Traits (X _is_ Y) {#{{{

    The "is" here indicates the trait:
        my $var is copy;
        my $var is rw;
        class MyChild is SomeParent {}
    
    But "is" is not mandatory for traits:
        class ThisClass does AnotherRole {}     # "does"
        has $.some_method handles <close>;      # "handles"

    Traits, like operators, can be user-defined as subs
        multi sub trait_mod:<VERB>( SIGNATURE ) { ...code... }


    CHECK - I don't understand why $doubles has the colon on the front or the 
    ! on the end yet.

    An actual example:
        multi trait_mod:<is>(Routine $r, :$doubles!) {
            $r.wrap({
                2 * callsame;
            });
        }
        sub square($x) is doubles { $x * $x }
        say square 3;   # 18
}#}}}
Re-Dispatching (callwith/same, nextwith/same) {#{{{

    Re-Dispatching uses the keywords:
        callwith
        callsame
        nextwith
        nextsame

        "call" - calls the next routine in the chain and returns.
        "next" - calls the next routine in the chain and DOES NOT return.

        "with" - pass along specific arguments to the next routine in the chain
        "same" - send along our current args to the next routine in the chain


    
    Defining multi routines creates a chain.  There are other ways of creating 
    chains, but let's start with that.

    The callchain starts with the most specific call.  Below, we have one 
    multi defined as accepting Int and another accepting Any.  We're passing 
    an Int, so the Int-accepting multi is the "most specific", and appears 
    first in the chain.

    Variations on "call", which returns:

        #####################
            multi a(Any $x) { say "Any $x" }
            multi a(Int $x) { say "Int $x"; callwith($x + 1); say "Back in Int $x." }
            a(1);
        #####################
        Outputs:
            Int 1
            Any 2
            Back in Int 1

        #####################
            multi b(Any $x) { say "Any $x" }
            multi b(Int $x) { say "Int $x"; callsame; say "Back in Int $x." }
            b(1);
        #####################
        Outputs:
            Int 1
            Any 1
            Back in Int 1

        Since call(with|same) returns, we can receive a retval if appropriate:
        #####################
            multi c(Any $x) { say "Any $x"; return $x + 3; }
            multi c(Int $x) {
                say "Int $x";
                my $rv = callsame;
                say "Back in Int $x, got $rv."
            }
            c(1);
        #####################
        Outputs:
            Int 1
            Any 1
            Back in Int 1, got 4.

    
    "next" is more or less the same deal, except it doesn't return:
        #####################
            multi d(Any $x) { say "Any $x" }
            multi d(Int $x) { say "Int $x"; nextsame; say "Back in Int $x." }
            d(1);
        #####################
        Outputs:
            Int 1
            Any 1
        ...and that's it.  The "Back in Int 1" does not display, because 
        nextsame did not return.

        Not bothering with a "nextwith" example, I think you get it at this 
        point.



    Other types of chained routines:
        - wrapped routines
            - currently over my head, CHECK
        - re-dispatching to a parent class


    So here's a class that inherits from a parent:
        class MyParent {
            method new(|c) {
                say "Parent class has the arguments " ~ c.perl;
            }
        }
        class MyKid is MyParent {
            method new(|c) {
                note "Creating a new kid with the arguments " ~ c.perl;

                nextsame;   # calls MyParent.new()

                ### wouldn't be called since nextsame doesn't return.
                note "blargle";
            }
        }



}#}}}
Re-Dispatching (multi routines with shared code) {#{{{
    
    https://doc.perl6.org/language/functions#proto


    If you have multi routines that take different arguments, those routines 
    are likely to share code between them that you don't want to repeat.

    In this situation there's a lot of re-typed code:
            class SomeClass {
                has $.config_file;

                multi sub make_config() {
                    $!config_file = '/path/to/default/file.cfg';
                    if path_does_not_exist($!config_file) {
                        make_dir( $!config_file );
                        touch_file( $!config_file );
                    }
                }
                multi sub make_config(Str $path) {
                    $!config_file = $path;
                    if path_does_not_exist($!config_file) {
                        make_dir( $!config_file );
                        touch_file( $!config_file );
                    }
                }
            }


    A better way of doing that is to use a proto sub:
            class SomeClass {
                has $.config_file;

                proto sub make_config(|) {
                    {*};
                    if path_does_not_exist($!config_file) {
                        make_dir( $!config_file );
                        touch_file( $!config_file );
                    }
                }
                multi sub make_config() {
                    $!config_file = '/path/to/default/file.cfg';
                }
                multi sub make_config(Str $path) {
                    $!config_file = $path;
                }
            }


    The | in the proto's signature is an unnamed capture.  It's going to 
    accept any (or no) arguments and pass them along untouched.
            proto sub make_config(|) {...}


    The {*} re-dispatches to the next appropriate routine in the chain, 
    passing along the args captured by (|).  After re-dispatching, we return 
    back to the proto again.





}#}}}
Coercion Types (Type Casting) {#{{{
    From the docs:
        Coercion types can help you to have a specific type inside a routine, 
        but accept wider input. When the routine is called, the argument is 
        automatically converted to the narrower type.

    The p6 "Cool" type is a value that can be treated as a string or a number 
    interchangeably.  Like 33 or 1.2.

    So we're going to accept any variable of type Cool and coerce it to an 
    int:
        sub double(Int(Cool) $x) {
            2 * $x;
        }
        say double 21;
        say double '21';    # wouldn't have worked if our sig required an Int.

        say double Any;     # Type check failed in binding $x; expected Cool but got Any


        Now, "foobar" is of type Cool, so it's not disallowed by the 
        signature:
            say double "foobar";
        However, the attempt to cast "foobar" to an Int fails with:
            Cannot convert string to number: ....JDB more message...
        This doesn't help make out point about coercions, it's just what 
        happens.
    
    You can coerce your own types:
        sub do_stuff( MyClass() $bar ) { }
    As long as $bar is of some type that's coerce-able into MyClass.  The 
    example in the tut is really contrived.  But if you need to do this, you 
    can.
}#}}}

### Stuff not from the tut, but which I've picked up from videos etc.
More on subsets {#{{{

    Ovid video:
        https://www.youtube.com/watch?v=lpu-3UF_b48
        I didn't mark the time, but it's before the currying section, which 
        starts at 19:46, so this "subsets" bit of the video happens before 
        that.

    
    We want our sub to accept a string, but want to make sure it's not empty.
            sub foo(Str $mystr) {
                if not $mystr.Bool {
                    die "\$mystr cannot be empty!";
                }
                ...do stuff because our string is not empty...
            }

    That's the standard way to deal with requiring a non-empty string as your 
    arg.  But with p6 we can define our own types ("subsets"), and then just 
    use that user-defined subset in our routine signature:

            subset NonEmptyString of Str where *.chars > 0;

            sub foo(NonEmptyString $str) {
                say "I got --$str--.";
            }

        Which gives us:
            foo('bar');         # I got --bar--.
            foo();              # Runtime error - too few positionals passed
            foo('');            # Runtime error - Constraint type check failed (Yay!)


    Ovid says that he thinks that NonEmptyString subset will probably be the 
    "most popular subset declared in Perl 6"


    Other examples:
        Require the password be between 8 and 24 characters, non-inclusive:
            subset Password of Str where 8 < *.chars < 24;

        Require the string be under 256 characters to fit into your database 
        column (if your column is defined as VARCHAR(256) and you pass in a 
        larger string, MySQL is just going to silently truncate it - yikes).
            subset DBColumn of Str where *.chars < 256;

        Only allow drivers between 16 and 90:
            subset DriverAge of Int where 16 <= * <= 90;

        etc

}#}}}
Caching (currying) functions {#{{{

    Ovid video
        https://www.youtube.com/watch?v=lpu-3UF_b48
        about 19:45 in
    

    This is a fibonacci sub that prints out the value of the Nth value in the 
    fib sequence:
            subset NonNegativeInt of Int where * >= 0;
            
            sub fib(NonNegativeInt $nth) {
                given $nth {
                    when 0 { 0 }
                    when 1 { 1 }
                    default { fib($nth-1) + fib($nth-2) }
                }
            }

            say fib(7);         # 13
            say fib(20);        # 6765, takes about a second
            say fib(30);        # 832040, takes about a MINUTE

    That's fine, and it returns the correct answer.  But the way it's 
    recursing means that the same value has to be passed through recursive 
    calls again and again.
    fib(20) has a noticeable pause, and fib(30) takes about a minute (I just 
    eyeballed the runtime, but it does take a while).

    Anyway, what we'd normally do in p5 is cache the previous results, 
    probably using CHI.

    With p6, caching is much simpler.  It's also experimental as I write this 
    (01/2016), but it looks veddy veddy nice.  All we have to do is declare 
    that we want to use the experimental caching feature, add then add the "is 
    cached" trait to the sub declaration:
            use experimental :cached;
            sub fib(NonNegativeInt $nth) is cached {
                given $nth {
                    when 0 { 0 }
                    when 1 { 1 }
                    default { fib($nth-1) + fib($nth-2) }
                }
            }

            say fib(7);         # 13
            say fib(20);        # 6765, takes under a second
            say fib(30);        # 832040, takes under a second

    Ovid, from the video: q|Perl 6 says "Here's a feature you can use.  Try 
    not to cut yourself with it."|

}#}}}
Introspection {#{{{

    Full docs on the Signature class that we're poking at here:
        http://doc.perl6.org/type/Signature


    
    Query a routine to figure out its signature:

            sub lower-right ( $x where {$x > 0}, $y where {$y < 0} --> Str ) {
                "Your point is located at ($x, $y).";
            }

            say &lower-right.signature;             # ($x where { ... }, $y where { ... } --> Str)
            say &lower-right.signature.perl;        # :($x where { ... }, $y where { ... } --> Str)
            say &lower-right.signature.arity;       # 2
            say &lower-right.signature.returns;     # (Str)
            say &lower-right.signature.params;      # ($x where { ... } $y where { ... })

    "arity" is the count of _required_ params.  For a sub like this:
                sub foo ( $x, $foo = 'bar' ) { ... }
        ...the arity is 1.  $foo has a default value, so you don't have to 
        pass it in.

    I'm not sure of the exact reason why ".signature" and ".signature.perl" 
    differ (the colon on output), but it's not upsetting me too much.



    .params actually returns a list, from which you can get info specific to 
    the various params.
                say &lower-right.signature.params;          # see above
                say &lower-right.signature.params[0].sigil; # $
                say &lower-right.signature.params[0].name;  # $x
                say &lower-right.signature.params[0].type;  # (Any)

        That'd be easier to read if we did this:
                my @p = &lower-right.signature.params;
                say @p[0].sigil;    # $
                say @p[0].name;     # $x
                say @p[0].type;     # (Any)



    Note that we prefixed the sub name with "&" in all cases above.  We don't 
    want to call the sub, which is what would happen if we left that sigil 
    off.  We want to address the container holding the sub.

}#}}}


### This stuff is over my head ATM and needs to be revisited.
### CHECK
Destructuring parameters {#{{{
    
    This seems a little odd.  

    Given this array:
        @arr = <jon red blue yellow orange>;

    We can make this sub:
        sub likes_colors (@arr ($name, *@colors) ) {
            for @colors -> $c {
                say "$name likes $c.";
            }
        }

    Or, we could skip naming @arr altogether.  This behaves identically to the 
    previous sub:
        sub likes_colors_2 ( [$name, *@colors] ) {
            for @colors -> $c {
                say "$name likes $c.";
            }
        }
        

    We can also destructure hashes in the same way, but that's over my head 
    right now.
}#}}}
Slurpy Conventions {#{{{

    This immediately started talking about stuff that I haven't covered 
    anywhere yet.
    
}#}}}

