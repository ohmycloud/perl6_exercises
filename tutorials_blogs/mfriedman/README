
http://friedo.com/blog/


Numeric Types {#{{{

    http://friedo.com/blog/2016/01/exploring-perl-6-numeric-types#more

    I've seen the youtube talk where jnthn talks about p6's mathematical 
    precision (eg getting 7/2 right).

    Here's the wiki article on Floats:
        https://en.wikipedia.org/wiki/Floating_point


    When doing fractional math, p6 generally wants to use Rat or FatRat types, 
    rather than floats.
            my $num1 = 1.23;
            say $num1.WHAT.perl;            # Rat

            my $rslt = 7 / 2;
            say $rslt;                      # 3.5
            say $rslt.WHAT.perl;            # Rat


        If you want to create a float, you have to do it specifically by 
        expressing the number in scientific notation.
                my $num2 = 123e-2;
                say $num2.WHAT.perl;        # Num


    Once you've got a Rat in hand, you can spit out its numerator and 
    denominator:
            my $rslt = 7 / 2;
            say $rslt.numerator;            # 7
            say $rslt.denominator;          # 2


    Native Rats are not as efficient as floats, because floats are 
    hardware-optimized.  However, unless you're doing pretty heavy amounts of 
    arithmetic, you won't notice the difference.

}#}}}
Hyperoperators {#{{{
    
    Apply an operation to a list.  Hyperoperators are "list-optimized 
    transforms that automatically benefit from p6's autothreading".


    Unary HOs {#{{{
        
        Apply the same method to a list of objects.
                my @arr = <1 3 5>;
                @arr>>.say;
        Output:
                1
                3
                5



        If there's a way of calling a subroutine, rather than a method, on 
        each element of the list, I haven't been able to figure out what that 
        way is yet.
                sub sayit (Int $number) { "I got $number."; }
                @arr>>sayit($_);            # GONNNNG!
                @arr>>sayit(.);             # GONNNNG!
                etc.

            The error complains about "missing dot on method call", so this 
            may well not be possible.
            
            OTOH, if we're looking to run a subroutine on a list of arguments, 
            we already have a perfectly good map, so we don't really need HOs 
            for that:
                map { sayit($_).say }, @arr;




        But these HOs seem awfully whitespace-sensitive.  The following forms 
        all throw compile errors:
                @arr >> .say;
                @arr>> .say;
                @arr >>.say;

        So remember to cram all that shit together.

    }#}}}
    Binary HOs (giggity) {#{{{
        
                my @nums = <1 3 5>;

        Apply an operator and argument to the list.



        Multiply each element by 3:
                say @nums >>*>> 3;          # [3 9 15]

            "Multiply each element in @nums by each element on the RHS.  When 
            the RHS supply is exhausted, start over from the beginning"

            Since our RHS above is a single scalar, it gets repeated for each 
            element in @nums.

            The arrow direction indicates LHS and RHS.  Above, the arrows are 
            pointing left to right, so the LHS is on the left, and the RHS is 
            on the right.

            But if we reverse the direction of the arrows, we swap the values 
            to the other sides, and get the same result:
                say 3 <<*<< @nums;          # [3 9 15]



        Square each element.  All three of these do the same thing:
                say @nums <<*<< @nums;      # [1 9 25]
                say @nums >>*>> @nums;      # [1 9 25]

            But if we're wanting squares, this might be better:
                say @nums >>**>> 2;         # [1 9 25]



        So far, our arrows have all been pointing in the same direction.  
        There are two cases where they point in different directions.

        I'm using multiplication in the examples here, but any operator will 
        do.

            - Facing Form ( >>*<< )
                - The list on each side must be of equal length.  Otherwise an 
                  error is thrown:
                        say <1 3 5> >>*<< <1 3 5>;      # (1 9 25)
                        say <1 3 5 7> >>*<< <1 3 5>;    # GONNNG!
                        say <1 3 5> >>*<< <1 3 5 7>;    # GONNNG!

            - Opposing Form ( <<*>> )
                - The two lists can be either the same size or different.  If 
                  they're of different sizes, the smaller one is assumed to be 
                  the one pointed at.
                        say <1 3 5> <<*>> <1 3 5>;      # (1 9 25) (same size)

                  So these produce the same thing.  In both cases, the larger 
                  list (1 3 5) is considered the LHS.
                        say <1 3> <<*>> <1 3 5>;      # (1 9 5)
                        say <1 3 5> <<*>> <1 3>;      # (1 9 5)

                     So we get:
                        1 * 1
                        3 * 3
                    ...and then we run out of elements on the RHS, so we warp 
                    back to the beginning of the RHS again, which is 1, so our 
                    next operation is
                        5 * 1


    }#}}}

}#}}}


